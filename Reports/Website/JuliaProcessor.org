* Julia Set Renderer
The Julia Set Renderer is a combination of compiler (written in Haskell) and a
custom VLIW processor/supporting framework running on an FPGA. Julia sets are fractal
shapes which are generated by iterating a point's coordinate in a rational
polynomial for every point in the complex plane. Under that iteration, the value
will either diverge to infinity eventually in which case it is not considered in
the set, or have a magnitude bounded by a some constant in which case it is
considered in the set.

This project gives the user a terminal in which to type a formula (for example
$z^2+c$) and draws the Julia set on a VGA screen. The user can use a mouse to
pan/zoom around the drawn set.

* Architecture
I started with my implementation of a solver for [[https://people.ece.cornell.edu/land/courses/ece5760/LABS/s2017/lab4_mandelbrot.html][Lab 4 - Mandelbrot Set]]. My
implementation used 27-bit, floating point arithmetic to draw regions of the
Mandelbrot set by mapping each pixel to a coordinate in the complex plane and
determining whether the iterated equation $Z_{n+1} = Z_n^2 + C$, where $Z_0=0 +
0i$ and $C$ is the coordinate corresponding to the pixel in question,
diverges. The color of the pixel is determined by how many iterations it took
for $Z$ to have magnitude greater than $2$ (after which the iterated equation
will provably diverge), capped at 1000 iterations.

For that project, implemented on the DE1-SoC development board, I used the HPS
(an ARM processor connected to the FPGA fabric via an AXI bus) to handle the UI
components including the mouse updates, and the FPGA to fill the VGA framebuffer
with colors based on how long it took the point to escape. The HPS updates the
parameters in the FPGA used to map the pixels on the screen to complex
coordinates based on the user inptus to enable the interactivity.

In the Mandelbrot set project my solver iterating the equation for $Z$ was
static and hand optimized for the given equation. In this project I replaced
that solver with a VLIW CPU designed to support a limited set of floating point
operations that could be used to iterate arbitrary equations (see [[VLIW
Processor]]). I also wrote a compiler which produces instructions to be run on the
VLIW processor (see [[Compiler]]).

I will first describe the architecture of the FPGA-side framework that sets up
the VLIW processor to solve a particular pixel, then the HPS-side UI components,
and finally the heart of this project - the VLIW processor and its compiler.

** Framework (FPGA)
*** Pixel Solver
The pixel solver, a shim around the the VLIW processor, provides an interface
for controlling the VLIW processor. Interfacing with the pixel solver consists
of waiting for the pixel solver to set a flag high indicating that it is ready
to receive a new input. On the same cycle that the inputs are ready a ~start~
signal is strobed which sets off the computation. The solver takes as inputs a
signal ~C_B~ which is the imaginary component of the value to be
iterated. Additionally, it accepts ~C_A_reference~ (floating point), ~C_A_step~
(floating point), and ~C_A_column~ (10-bit unsigned number), which specify the
real component of the point's location by the expression $C\_A\_reference +
C\_A\_step * C\_A\_column$. Passing those values to the solver instead of
computing them outside the solver is an optimization which allows using the
solver's instantiated adder/multiplier instead of instantiating new ones as
resources on the board are in high demand. When the solver is done, it sets it's
output ~num_iterations~ to the number of iterations it took to escape the
threshold and strobes the outut ~done~ (effectively sending an interrupt). A new
value may now be loaded.

*** Row Solver
The row solver instantiates a single pixel solver, but provides an additional
abstraction. The row solver accepts the imaginary coordinate of the point to be
operated, the first real value, and the real step size (those are passed
directly directly to the pixel solver in addition to the column number which the
row solver generates). The row solver has a similar request/grant interface for
inputs. The row solver generates a pixel's value, column index, and row index
strobing another output each time the outputs are valid.

The row solver supplies the nested pixel solver with the necessary inputs,
starting at column 0. When the pixel solver strobes that an output is ready that
is combinationally passed to the row solver's outputs (additional outputs of the
row solver are set when the solver receives its ~grant~ and are constant for the
duration of the row). Each time the pixel solver completes the row solver
increments the column count and restarts the pixel solver on the next cycle
unless the end of the row has been reached in which case the row solver enters
the reset state, awaiting another ~grant~.

*** Frame Solver
The frame solver accepts the coordinates of the top left corner of the screen
and the step sizes for the real and imaginary axes. The frame solver
instantiates more than 45 row solvers and coordinates the inputs and outputs
to/from each. At most one row solver is given a ~grant~ in a particular cycle
(so it takes at least 45 cycles to get the row solvers all computing). On any
cycle when at least one row solver's ~request~ flag is set high the lowest
indexed row solver whose ~request~ is high receives a ~grant~ and gets assigned
an imaginary coordinate corresponding to the row it should start computing. The
imaginary coordinate is incremented by the imaginary step size using an
adder. If no row solvers are have their ~request~ flag set then no action is
taken. If the row index exceeds the frame size then it is reset to 0 and the
running count of the imaginary coordinate is reset to the initial value (that of
the top left corner).

The output of each row solver is fed into a corresponding true dual-ported
FIFO. Each time the row solver strobes its output signal the coordinates of the
most recently generated pixel and the pixel's value are concatenated and
inserted into a FIFO.

On a separate clock domain, the outputs of the FIFOs are arbitrated and used as
the outputs of the frame solver. On each clock cycle on the ~output_clk~
domain a pixel's coordinates and value may be output; if one is available on
that cycle then a strobe signal is set high. FIFOs are emptied with those having
lowest index having highest priority. While that is not fair, it doesn't impact
the draw time of the solver since the high-indexed solvers will simply be
blocked when framebuffer bandwidth is the limiting factor and since solvers are
not pre-assigned rows a subsequent change in the cause of the bottleneck would
not disproportionately leave some solvers "out of work".

*** Top Level
The top level module instantiates a single frame solver and interfaces it with
the HPS PIO signals and the VGA framebuffer. The VGA framebuffer is a
dual-ported SRAM with one port dedicated to the VGA subsystem and the second
exported from QSYS into Verilog. The output interface of the Frame Solver
conveniently wires combinationally into the input interface of the SRAM; each
time the frame solver's strobe indicating an output is available is wired to the
SRAM's write enable and the frame solver's pixel coordinates combinationally
determine the address to which the frame solver's iteration count output should
be written. This is by design to minimize logic which can't be unit tested in
ModelSim (the top level module is the only module not tested in ModelSim, as is
discussed later). The SRAM's value is an 8-bit color which is determined by the
bottom eight bits of the number of iterations that point took to escape.

The top level module also keeps track of the number of cycles it takes to
compute each frame which is passed to the HPS to display in milliseconds on the display.

*** QSys
TODO

** User Control (HPS)
The HPS, running Linux, is responsible for updating the PIO registers with the
current frame's top-left-corner position and step size. The user's mouse
movements are scaled based on the current zoom and used to update the position,
while the left/right mouse buttons increased and decreased the zoom by updating
the step size and the top-left-corner position accordingly to keep the image
centered during a zoom (otherwise you would be zooming into the top left
corner).

The HPS loads the a program generated by the compiler into the program memory
when the HPS program is launched.

The HPS also displays the current coordinates and the frame generation time on
the display in the text buffer.

* Program/hardware design:
    # program details. What parts were tricky to write?
    # hardware details. Could someone else build this based on what you have written?
    # Be sure to specifically reference any design or code you used from someone else.
    # Things you tried which did not work
** Compiler

$z*z+1i2$

*** Parser
data Exp = Num Int
         | Cpx Exp Exp -- complex
         | Var String
         | Add Exp Exp
         | Sub Exp Exp
         | Mul Exp Exp
         | Div Exp Exp
         | Pow Exp Exp
         | Pos Exp
         | Neg Exp
           deriving (Show)

#+BEGIN_SRC haskell
Right (Add (Mul (Var "z") (Var "z")) (Cpx (Num 1) (Num 2)))
#+END_SRC

*** IR
#+BEGIN_SRC haskell
data Instruction =
  --     SRC1     SRC2     DEST
    Add  Register Register Register
  | Mul  Register Register Register
  --     SRC      DEST
  | Neg  Register Register
  --     Val      DEST
  | Load Int      Register
  --     DEST
  | Var  Register
                 deriving (Show)
#+END_SRC

#+BEGIN_SRC haskell
type Complex = (Register, Register)
preschedule :: JuliaParser.Exp -> State Int ([[Instruction]], Complex)

data Cycle = Cycle { load :: Maybe Instruction
                   , add  :: Maybe Instruction
                   , mul  :: Maybe Instruction
                   , neg  :: Maybe Instruction
                   } deriving (Show)

flattenSchedule :: [[Instruction]] -> [Cycle]
#+END_SRC

#+BEGIN_SRC haskell
[
  Cycle {load = Nothing,          add = Nothing,                mul = Nothing,            neg = Nothing},
  Cycle {load = Nothing,          add = Nothing,                mul = Nothing,            neg = Nothing},
  Cycle {load = Nothing,          add = Just (Add 4 5 2),       mul = Nothing,            neg = Nothing},
  Cycle {load = Nothing,          add = Nothing,                mul = Just (Mul 0 0 4),   neg = Nothing},
  Cycle {load = Nothing,          add = Nothing,                mul = Just (Mul 1 1 5),   neg = Nothing},
  Cycle {load = Nothing,          add = Nothing,                mul = Nothing,            neg = Nothing},
  Cycle {load = Nothing,          add = Just (Add 4 522 0),     mul = Nothing,            neg = Nothing},
  Cycle {load = Nothing,          add = Just (Add 4 523 1),     mul = Nothing,            neg = Nothing},
  Cycle {load = Just (Load 0 4),  add = Nothing,                mul = Nothing,            neg = Nothing},
  Cycle {load = Nothing,          add = Nothing,                mul = Nothing,            neg = Nothing},
  Cycle {load = Nothing,          add = Just (Add 525 20 523),  mul = Nothing,            neg = Nothing},
  Cycle {load = Nothing,          add = Just (Add 524 19 522),  mul = Nothing,            neg = Nothing},
  Cycle {load = Just (Load 2 20), add = Nothing,                mul = Nothing,            neg = Nothing},
  Cycle {load = Just (Load 1 19), add = Nothing,                mul = Nothing,            neg = Nothing},
  Cycle {load = Nothing,          add = Just (Add 785 784 525), mul = Nothing,            neg = Nothing},
  Cycle {load = Nothing,          add = Nothing,                mul = Just (Mul 1 0 785), neg = Nothing},
  Cycle {load = Nothing,          add = Nothing,                mul = Just (Mul 0 1 784), neg = Nothing},
  Cycle {load = Nothing,          add = Just (Add 274 782 524), mul = Nothing,            neg = Nothing},
  Cycle {load = Nothing,          add = Nothing,                mul = Nothing,            neg = Just (Neg 783 274)},
  Cycle {load = Nothing,          add = Nothing,                mul = Just (Mul 1 1 783), neg = Nothing},
  Cycle {load = Nothing,          add = Nothing,                mul = Just (Mul 0 0 782), neg = Nothing}
]
#+END_SRC

*** Assembler
#+BEGIN_SRC haskell
encodeLoad :: Maybe IR.Instruction -> BV.BV
assemble :: [IR.Cycle] -> [Word128]
#+END_SRC

Reversed and assembled:
#+BEGIN_SRC
[
  1073742606,
  1074792207,
  8534579836514498005434368,
  2924556919630725120,
  1073743632,
  1074791185,
  4075231024617881600,
  1329228005872192911768272894028677120,
  1329228015785384632608232126619320320,
  3485829014013083648,
  3488083014997508096,
  0,
  1329227995823601499131475193870942208,
  2316000299778572288,
  2315998098607833088,
  0,
  1074791429,
  1073741828,
  2314861207879680000,
  0,
  0
]
#+END_SRC

** VLIW Processor
The VLIW processor, as indicated in [[Compiler][Compiler]], has Load, Neg, Add,
and Mul pipes. It additionally has a register file and all the logic required to marshal data to and from registers/pipes as needed.

The processor has a floating point register file where the first three registers
(indexes 0-2) are special-purpose and the remainder are general
purpose. Registers 0 and 1 are designated to hold the real and imaginary
components of $Z$ respectively. Thus, the compiled program can count on the
result of the previous iteration being there and is responsible for storing the
result of its computation there as well. In the next section I describe how
$Z_0$ is loaded into those registers. Register 2 is special-purposed to throw an
interrupt when a value larger than ~max_magnitude~ is written to it. The last
thing the compiled programs do is calculate the squared magnitude of $Z_n$ and
write it to register 2; if the magnitude has escaped the threshold then the
processor sets its ~done~ flag high (the VLIW processor takes no further action,
but the Row Solver's response is described next).

** Row Solver
The Row Solver has two (TODO) states: a ~reset/init~ state and ~compute~ state. An
interesting note is that the pixel solver is restarted within the same cycle as
it finishes if the row solver hasn't reached the end of the row yet, saving
hundreds of cycles per row. Otherwise, this is a pretty trivial implementation.

Note that the signals that start with ~solver_~ reference the pixel
solver's signals, not the row solver's. 

#+BEGIN_SRC verilog
parameter state_reset=0, state_compute=1;
always @(posedge solver_clk) begin
   if(reset || state == state_reset) begin
      state <= state_reset;
      start_request <= 1;
      if (start_grant) begin
         state <= state_compute;
         start_request <= 0;
         output_row_idx <= row_y_idx;
         // start the simulation of the first element of the row
         solver_C_A_reference <= row_x_reference;
         solver_C_A_step      <= row_x_step;
         column_idx           <= 0;
         solver_C_B           <= row_y;
         solver_start         <= 1;
      end
   end
   else if (state == state_compute) begin
      if (solver_start) solver_start <= 0; // only needs to be hi once
      if (solver_done) begin
         // receive results
         // start on new results
         if (column_idx == 639) begin // just finished last column
            state <= state_reset;
         end
         else begin
            column_idx   <= column_idx + 1;
            solver_start <= 1;
         end
      end
   end
end
#+END_SRC

** Frame Solver
The frame solver consists of two main components: the arbiters getting data
to/from the row sovlers and a generate loop which instantiates the row
solvers/their FIFOs.

A minimal state machine generates a new imaginary number corresponding to a row
that needs to be computed every time a row solver receives a grant:

#+BEGIN_SRC verilog
always @(posedge solver_clk) begin
   frame_done_stb <= 0; // default value
   if (reset) begin
      row_next_y_idx <= 0;
      row_next_y_value <= y_0;
   end
   else if (row_next_y_idx == 479) begin
      // frame is done
      row_next_y_idx <= 0;
      frame_done_stb <= 1;
      // reset things
      row_next_y_idx <= 0;
      row_next_y_value <= y_0;
   end
   else if (row_solver_start_grant > 0) begin
      row_next_y_idx <= row_next_y_idx + 1;
      row_next_y_value <= row_next_y_value_adder_out;
   end
end
#+END_SRC

That ~row_next_y_value~ is wired to all of the row solvers, but the
start grant signal (a one-hot signal) means that at most a single row solver
will latch that ~row_next_y_value~ on any cycle. That grant signal is
given to the row solver with smallest index AND whose start request signal is
high. The signal is generated by the ~Reqs_To_One_Hot~ module.

That same ~Reqs_To_One_Hot~ module is instantiated a second time to
arbitrate which row solver gets to return a value in a given cycle. The
arbiter's input is a wire with each bit set by the inverse of a FIFO's
~empty~ signal; that is, when a FIFO is not empty it is making a request
to the arbiter. When the arbiter gives that FIFO a grant the FIFO's output is
muxed to the frame solver's outputs and the FIFO receives a ~rdreq~
signaling that it should advance its output.

The generator for loop instantiates the row solvers and FIFOs. The size of all
the connections and the loop are all parameterized by
~NUM_ROWS_SOLVERS~.


* Results of the design:

    # Any and all test data, scope traces, waveforms, etc
    # speed of execution (hesitation, filcker, interactiveness, concurrency)
    # accuracy (numeric, music frequencies, video signal timing, etc)
    # how you enforced safety in the design.
    # interference with other people's designs (e.g. cpu noise, RF interference)
    # usability by you and other people

* Conclusions:

    # Analyse your design in terms of how the results met your expectations. What might you do differently next time?
    # How did your design conform to the applicable standards?
    # Intellectual property considerations.
    #     Did you reuse code or someone else's design? Did you use any of Altera's IP?
    #     Did you use code in the public domain?
    #     Are you reverse-engineering a design? How did you deal with patent/trademark issues?
    #     Did you have to sign non-disclosure to get a sample part?
    #     Are there patent opportunites for your project?
    # Legal considerations. For instance, if you use a transmitter, you must discuss the appropriate FCC legal restrictions.


* Appndix A
- The group approves this report for inclusion on the course website.
- The group approves the video for inclusion on the course youtube channel.

* Appendix with commented Verilog and/or program listings. When posting code, you must comply with all Altera IP considerations.
* Appendix with schematics if you build hardware external to the DE2 board (you can download free software from expresspcb.com to draw schematics).
* Appendix with a list of the specific tasks in the project carried out by each team member.
* References you used:
    # Data sheets
    # Vendor sites
    # Code/designs borrowed from others
    # Background sites/paper

